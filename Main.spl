use com.ibm.streams.db::ODBCSource ;
use com.ibm.streams.db::ODBCEnrich ;

composite Main
{
    type
        BIG_DATA_DATAMART_TYPE = rstring KULLANICI_KIMLIK, int32 ADSL_NO, rstring IL,
            rstring ILCE, rstring MAHALLE, rstring MUDURLUK, float64 SANTRAL,
            rstring DSLAM, rstring DSLAM_IP, float64 MPLS_ID, rstring MPLS_ADI,
            float64 REDBACK_ID, rstring REDBACK_NAME, rstring SERVIS, rstring BOLGE_ADI,
            rstring ADSL_SATIS_TARIHI, rstring PROD_OFR, rstring URUN_STATUSU,
            rstring SON_GERCEKLESEN_BI, rstring SON_GERCEKLESEN_BI_TARIHI,
            rstring SON_NAKIL_TARIHI, rstring CUST_TP, rstring DSL_QUOTA,
            float64 LIMITLI_LIMITSIZ, float64 IS_NDSL, rstring IPTV_NO,
            rstring FIBER_MIGRATION_TARIHI, rstring CHURN_DATE,
            rstring SON_ARIZA_KAYDI_TARIHI, rstring SON_ARIZA_TIPI, float64 IS_VIP ;
    graph

    /* 
        stream<BIG_DATA_DATAMART_TYPE> ReadFromDB = ODBCSource()
        {
            param
                connectionDocument : "./etc/connections.xml" ;
                connection : "BIGDATALOOKUP" ;
                access : "readFromSubscriberLookup" ;
        }   
        */
        stream<BIG_DATA_DATAMART_TYPE> ReadFromDB = ODBCEnrich(RefreshMe)
        {
            param
                connection : "BIGDATALOOKUP" ;
                access : "enrichFromSubscriberLookup" ;
                connectionDocument : "./etc/connections.xml" ;
                LASTREFRESH : mylastrefresh ;
        }

        stream<int32 mylastrefresh> RefreshMe = Beacon()
        {
            param
                period : 600.0 ;
                // iterations : 3

            output
                RefreshMe : mylastrefresh = 1w ;
        }

        (stream<int32 cdr_ADSL_NO, rstring cdr_TYPE, rstring cdr_REASON,
            int64 download, int64 upload, rstring lastBillingDate> CustomerStream) as
            GenerateCDRData = Beacon()
        {
            param
                initDelay : 3.0 ;
                period : 1.0 ;
                iterations : 500 ;
            output
                CustomerStream : cdr_ADSL_NO = 1800000000 +(int32)(random() * 5000.0),
                    cdr_TYPE = "START", cdr_REASON = "USER_REQUEST",
                    download =(int64)(random() * 50000.0), upload =(int64)(random() *
                    30000.0), lastBillingDate =(int32)(random() * 3.0) % 2 == 1 ? "BillDate1"
                    : "BillDate2" ;
        }

        stream<BIG_DATA_DATAMART_TYPE, tuple<int32 cdr_ADSL_NO, rstring cdr_TYPE,
            rstring cdr_REASON, int64 download, int64 upload, rstring lastBillingDate>>
            AUGMENTEDRADIUSSTREAM = Join(ReadFromDB as inPort0Alias ; CustomerStream as
            inPort1Alias)
        {
            window
                inPort0Alias : sliding, count(1), partitioned ;
                inPort1Alias : sliding, count(0) ;
            param
                partitionByLHS : inPort0Alias.ADSL_NO ; //TODO: KULLANICI_KIMLIK
                algorithm : rightOuter ;
                equalityLHS : inPort0Alias.ADSL_NO ; //TODO: KULLANICI_KIMLIK
                equalityRHS : inPort1Alias.cdr_ADSL_NO ; //TODO: KULLANICI_KIMLIK

        }

        () as FileSink_4 = FileSink(CUSTOMERSTATUS as MATCHRULE1)
        {
            param
                file : "outDATA.txt" ;
                format : csv ;
        }

        () as SENDUNMATCHEDDATATOHDFS = FileSink(MATCHRULE_out1 as MATCHRULE2)
        {
            param
                file : "unmatchedDATA.txt" ;
                format : csv ;
        }

        (stream<BIG_DATA_DATAMART_TYPE, tuple<int32 cdr_ADSL_NO, rstring cdr_TYPE,
            rstring cdr_REASON, int64 download, int64 upload, rstring lastBillingDate>>
            MATCHRULE ; stream<BIG_DATA_DATAMART_TYPE, tuple<int32 cdr_ADSL_NO,
            rstring cdr_TYPE, rstring cdr_REASON, int64 download, int64 upload,
            rstring lastBillingDate>> MATCHRULE_out1) as SplitByMATCHRULE =
            Split(AUGMENTEDRADIUSSTREAM)
        {
            param
                index : ADSL_NO == 0 ? 1 : ADSL_NO != 0 ? 0 : - 1 ;
            }

        stream<MATCHRULE, tuple<int32 status>> CUSTOMERSTATUS = Functor(MATCHRULE)
            {
                logic
                    state :
                    {
                        mutable set<int32> custSet ;
                        mutable int32 internalStatus ;
                        //mutable int32 sum ;

                    }

                    onTuple MATCHRULE :
                    {
                        internalStatus = 0 ;
                        insert(custSet, ADSL_NO) ;
                        if((cdr_TYPE == "START" || cdr_TYPE == "INTERIM") && !(ADSL_NO in
                            custSet))
                        {
                            internalStatus = 1 ;
                            insertM(custSet, ADSL_NO) ;
                        }

                        else if((cdr_TYPE == "STOP") &&(ADSL_NO in custSet))
                        {
                            internalStatus = - 1 ;
                            removeM(custSet, ADSL_NO) ;
                        }

                        //sum +=(int32) internalStatus ;

                    }

                    param
                        filter : internalStatus != 0 ;
                    output
                        CUSTOMERSTATUS : status = internalStatus ;
                }

            () as SENDMATCHDATATOHDFS = FileSink(MATCHRULE)
                {
                    param
                        file : "matchDataToHDFS" ;
                        format : csv ;
                }

                /*stream<rstring ADSL_NO, int64 totalDownload, rstring lastBillingDate, int64 download> CUSTOMERDATA = Functor(MATCHRULE)
            {
                logic
                    state :
                    {
                        mutable map<rstring,tuple<float64 FirstRecord,float64 Interm, float64 Stop, rstring BillCycleTimestamp>> custDataUsageMap ;
                    }

                    onTuple MATCHRULE :
                    {
                        if (! ((rstring)ADSL_NO in custDataUsageMap)){
                            if(cdr_CDR_TYPE == "START")
                               insertM(custDataUsageMap, (rstring)ADSL_NO,{ FirstRecord=0.0,Interm=0.0,Stop=0.0,BillCycleTimestamp=""});
                            else if(cdr_CDR_TYPE == "STOP")  
                               insertM(custDataUsageMap, (rstring)ADSL_NO,{ FirstRecord=0.0,Interm=0.0,Stop=download,BillCycleTimestamp=""});
                            else if(cdr_CDR_TYPE == "INTERM")  
                               insertM(custDataUsageMap, (rstring)ADSL_NO,{ FirstRecord=0.0,Interm=download,Stop=0.0,BillCycleTimestamp=""});
                        }else{
                            if (custDataUsageMap[(rstring)ADSL_NO].BillCycleTimestamp == ""){
                               if(cdr_CDR_TYPE == "START"){
                               
                               }else if(cdr_CDR_TYPE == "STOP"){
                                   custDataUsageMap[(rstring)ADSL_NO].Stop += download;
                                   custDataUsageMap[(rstring)ADSL_NO].Interm = 0.0;
                               }
                                else if(cdr_CDR_TYPE == "INTERM")  
                                   custDataUsageMap[(rstring)ADSL_NO].Interm += download;
                            }else{
                               custDataUsageMap[(rstring)ADSL_NO].BillCycleTimestamp = "";
                            
                               if(cdr_CDR_TYPE == "START"){
                                   custDataUsageMap[(rstring)ADSL_NO].FirstRecord = 0.0;
                                   custDataUsageMap[(rstring)ADSL_NO].Stop = 0.0;
                                   custDataUsageMap[(rstring)ADSL_NO].Interm = 0.0;
                               }else if(cdr_CDR_TYPE == "STOP"){
                                   custDataUsageMap[(rstring)ADSL_NO].Stop = download;
                                   custDataUsageMap[(rstring)ADSL_NO].Interm = 0.0;
                               }
                                else if(cdr_CDR_TYPE == "INTERM")  
                                   custDataUsageMap[(rstring)ADSL_NO].Interm += download;
                            }
                        }
                        //CHECK ALARM
                    }    

                }*/
            stream<rstring KULLANICI_KIMLIK, int64 totalDownload,
                rstring lastBillingDate, int64 download, int8 numericQuota>
                CUSTOMERDOWNLOADDATA = Functor(MATCHRULE)
                {
                    logic
                        state :
                        {
                            mutable map<rstring, tuple<int64 firstRecord, int64 currentInterim,
                                int64 totalStops, rstring lastBill>> total ;
                        }

                        onTuple MATCHRULE :
                        { // New KULLANICI_KIMLIK in map// New Billing Cycle
                            if(!(KULLANICI_KIMLIK in total) || lastBillingDate != total [
                                KULLANICI_KIMLIK ].lastBill) total [ KULLANICI_KIMLIK ] = { firstRecord
                                = download, currentInterim = download, totalStops = 0l, lastBill =
                                lastBillingDate } ;
                            if(cdr_TYPE == "START" || total [ KULLANICI_KIMLIK ].currentInterim >
                                download)
                            {
                                total [ KULLANICI_KIMLIK ].totalStops += total [ KULLANICI_KIMLIK
                                    ].currentInterim ;
                                total [ KULLANICI_KIMLIK ].currentInterim = download ;
                            }

                            else
                            {
                                total [ KULLANICI_KIMLIK ].currentInterim = download ;
                                if(cdr_TYPE == "STOP")
                                {
                                    total [ KULLANICI_KIMLIK ].totalStops += total [ KULLANICI_KIMLIK
                                        ].currentInterim ; // Already added stop's download
                                    total [ KULLANICI_KIMLIK ].currentInterim = 0l ;
                                }

                            }

                        }

                        output
                            CUSTOMERDOWNLOADDATA : totalDownload = total [ KULLANICI_KIMLIK
                                ].totalStops + total [ KULLANICI_KIMLIK ].currentInterim - total [
                                KULLANICI_KIMLIK ].firstRecord, numericQuota = LIMITLI_LIMITSIZ == 0.0
                                ? 15b :(DSL_QUOTA == "4" ? 4b : 6b) ;
                    }

                stream<rstring KULLANICI_KIMLIK, int64 totalUpload,
                    rstring lastBillingDate, int64 upload, int8 numericQuota>
                    CUSTOMERUPLOADDATA = Functor(MATCHRULE)
                    {
                        logic
                            state :
                            {
                                mutable map<rstring, tuple<int64 firstRecord, int64 currentInterim,
                                    int64 totalStops, rstring lastBill>> total ;
                            }

                            onTuple MATCHRULE :
                            { // New KULLANICI_KIMLIK in map// New Billing Cycle
                                if(!(KULLANICI_KIMLIK in total) || lastBillingDate != total [
                                    KULLANICI_KIMLIK ].lastBill) total [ KULLANICI_KIMLIK ] = {
                                    firstRecord = upload, currentInterim = upload, totalStops = 0l,
                                    lastBill = lastBillingDate } ;
                                if(cdr_TYPE == "START" || total [ KULLANICI_KIMLIK ].currentInterim >
                                    upload)
                                {
                                    total [ KULLANICI_KIMLIK ].totalStops += total [ KULLANICI_KIMLIK
                                        ].currentInterim ;
                                    total [ KULLANICI_KIMLIK ].currentInterim = upload ;
                                }

                                else
                                {
                                    total [ KULLANICI_KIMLIK ].currentInterim = upload ;
                                    if(cdr_TYPE == "STOP")
                                    {
                                        total [ KULLANICI_KIMLIK ].totalStops += total [ KULLANICI_KIMLIK
                                            ].currentInterim ; // Already added stop's download
                                        total [ KULLANICI_KIMLIK ].currentInterim = 0l ;
                                    }

                                }

                            }

                            output
                                CUSTOMERUPLOADDATA : totalUpload = total [ KULLANICI_KIMLIK
                                    ].totalStops + total [ KULLANICI_KIMLIK ].currentInterim - total [
                                    KULLANICI_KIMLIK ].firstRecord, numericQuota = LIMITLI_LIMITSIZ == 0.0
                                    ? 15b :(DSL_QUOTA == "4" ? 4b : 6b) ;
                        }

                    stream<rstring IL, rstring ILCE, int32 sum> TOTALCUSTOMER =
                            Aggregate(CUSTOMERSTATUS)
                        {
                            window
                                CUSTOMERSTATUS : tumbling, time(1.5) ;
                            param
                                groupBy : IL, ILCE ;
                            output
                                TOTALCUSTOMER : sum = Sum((int32) status) ;
                        }

                    () as TOTALCUSTOMERFILE = FileSink(TOTALCUSTOMER)
                        {
                            param
                                file : "abonesayilari.txt" ;
                                format : csv ;
                        }

                    stream<CUSTOMERDOWNLOADDATA, tuple<int8 alertType>> DOWNLOADQUOTAALERT =
                            Functor(CUSTOMERDOWNLOADDATA)
                        {
                            logic
                                state :
                                {
                                    mutable map<rstring, tuple<rstring lastBill,
                                        float64 newExceedPercent>> pastAlerts ;
                                    mutable float64 oldRatio ;
                                }

                                onTuple CUSTOMERDOWNLOADDATA :
                                {
                                    if(!(KULLANICI_KIMLIK in pastAlerts) || pastAlerts [ KULLANICI_KIMLIK
                                        ].lastBill != lastBillingDate) pastAlerts [ KULLANICI_KIMLIK ] = {
                                        lastBill = lastBillingDate, newExceedPercent = 0.0 } ;
                                    oldRatio = pastAlerts [ KULLANICI_KIMLIK ].newExceedPercent ;
                                    pastAlerts [ KULLANICI_KIMLIK ].newExceedPercent =(float64)
                                        totalDownload /(float64)(((int64) numericQuota) << 30) ;
                                }

                                param
                                    filter :(oldRatio < 1.0 && pastAlerts [ KULLANICI_KIMLIK
                                        ].newExceedPercent >= 1.0) ||(oldRatio < 0.8 && pastAlerts [
                                        KULLANICI_KIMLIK ].newExceedPercent >= 0.8) ;
                                output
                                    DOWNLOADQUOTAALERT : alertType = numericQuota == 15b ?(pastAlerts [
                                        KULLANICI_KIMLIK ].newExceedPercent >= 1.0 ? 4b : 3b) :(pastAlerts [
                                        KULLANICI_KIMLIK ].newExceedPercent >= 0.8 ? 2b : 1b) ;
                            }

                        () as OVERQUOTA = FileSink(DOWNLOADQUOTAALERT)
                            {
                                param
                                    file : "overquota.txt" ;
                                    format : csv ;
                            }

                        () as QUOTA = FileSink(CUSTOMERDOWNLOADDATA)
                            {
                                param
                                    file : "quota.txt" ;
                                    format : csv ;
                            }

                        stream<rstring DSLAM, int32 status> DSLAMCUSTOMERLIST =
                                Functor(CUSTOMERSTATUS)
                            {
                                logic
                                    state :
                                    {
                                        mutable map<rstring, tuple<int32 internalStatus>> dslamMap ;
                                    }

                                    onTuple CUSTOMERSTATUS :
                                    {
                                        if(DSLAM in dslamMap)
                                        {
                                            dslamMap [ DSLAM ].internalStatus += status ;
                                        }

                                        else
                                        {
                                            insertM(dslamMap, DSLAM, { internalStatus = 0 }) ;
                                        }

                                    }

                                output
                                    DSLAMCUSTOMERLIST : status = dslamMap [ DSLAM ].internalStatus ;
                            }

                        stream<float64 REDBACK_ID, int32 status> REDBACKCUSTOMERLIST =
                                Functor(CUSTOMERSTATUS)
                            {
                                logic
                                    state :
                                    {
                                        mutable map<rstring, tuple<int32 internalStatus>> redbackMplsMap ;
                                    }

                                    onTuple CUSTOMERSTATUS :
                                    {
                                        if((rstring) REDBACK_ID in redbackMplsMap)
                                        {
                                            redbackMplsMap [(rstring) REDBACK_ID ].internalStatus += status ;
                                        }

                                        else
                                        {
                                            insertM(redbackMplsMap,(rstring) REDBACK_ID, { internalStatus = 0
                                                }) ;
                                        }

                                    }

                                output
                                    REDBACKCUSTOMERLIST : status = redbackMplsMap [(rstring) REDBACK_ID
                                        ].internalStatus ;
                            }

                        stream<float64 MPLS_ID, int32 status> MPLSCUSTOMERLIST =
                                Functor(CUSTOMERSTATUS)
                            {
                                logic
                                    state :
                                    {
                                        mutable map<rstring, tuple<int32 internalStatus>> mplsMap ;
                                    }

                                    onTuple CUSTOMERSTATUS :
                                    {
                                        if((rstring) MPLS_ID in mplsMap)
                                        {
                                            mplsMap [(rstring) MPLS_ID ].internalStatus += status ;
                                        }

                                        else
                                        {
                                            insertM(mplsMap,(rstring) MPLS_ID, { internalStatus = 0 }) ;
                                        }

                                    }

                                output
                                    MPLSCUSTOMERLIST : status = mplsMap [(rstring) MPLS_ID
                                        ].internalStatus ;
                            }

                        stream<rstring DSLAM, int32 status, int32 maxStatus> DSLAMCUSTOMERGROUP =
                                Aggregate(DSLAMCUSTOMERLIST)
                            {
                                window
                                    DSLAMCUSTOMERLIST : sliding, time(180), partitioned ;
                                param
                                    partitionBy : DSLAM ;
                                    aggregateIncompleteWindows : true ;
                                output
                                    DSLAMCUSTOMERGROUP : maxStatus = Max(status) ;
                            }

                        stream<float64 REDBACK_ID, int32 status, int32 maxStatus>
                            REDBACKCUSTOMERGROUP = Aggregate(REDBACKCUSTOMERLIST)
                            {
                                window
                                    REDBACKCUSTOMERLIST : sliding, time(300), partitioned ;
                                param
                                    partitionBy : REDBACK_ID ;
                                    aggregateIncompleteWindows : true ;
                                output
                                    REDBACKCUSTOMERGROUP : maxStatus = Max(status) ;
                            }

                        stream<float64 MPLS_ID, int32 status, int32 maxStatus>
                            MPLSCUSTOMERGROUP = Aggregate(MPLSCUSTOMERLIST)
                            {
                                window
                                    MPLSCUSTOMERLIST : sliding, time(300), count(1), partitioned ;
                                param
                                    partitionBy : MPLS_ID ;
                                    aggregateIncompleteWindows : true ;
                                output
                                    MPLSCUSTOMERGROUP : maxStatus = Max(status) ;
                            }

                        stream<float64 REDBACK_ID, int32 status, int32 redbackCount>
                            REDBACKCUSTOMERGROUP2 = Aggregate(Filter_38_out0 as inPort0Alias)
                            {
                                window
                                    inPort0Alias : sliding, time(180), partitioned ;
                                param
                                    partitionBy : REDBACK_ID ;
                                output
                                    REDBACKCUSTOMERGROUP2 : redbackCount = Count() ;
                            }

                        stream<float64 MPLS_ID, int32 status, int32 mplsStopCount>
                            MPLSCUSTOMERGROUP2 = Aggregate(Filter_38_out0 as inPort0Alias)
                            {
                                window
                                    inPort0Alias : sliding, time(180), count(10), partitioned ;
                                param
                                    partitionBy : MPLS_ID ;
                                    aggregateIncompleteWindows : true ;
                                output
                                    MPLSCUSTOMERGROUP2 : mplsStopCount = Count() ;
                            }

                        stream<rstring DSLAM, int32 status, int32 maxStatus> DSLAMALERT =
                                Custom(DSLAMCUSTOMERGROUP ; PARAMETERS)
                            {
                                logic
                                    state :
                                    {
                                        mutable float64 rate = 30.0 ;
                                        mutable int32 sum ;
                                    }

                                    onTuple DSLAMCUSTOMERGROUP :
                                    {
                                        if(((float64) status /(float64) maxStatus) <= rate / 100.0)
                                        {
                                            submit(DSLAMCUSTOMERGROUP, DSLAMALERT) ;
                                        }

                                    }

                                    onTuple PARAMETERS :
                                    {
                                        rate = DSLAMAlertRate ;
                                    }

                            }

                        stream<float64 REDBACK_ID, int32 status, int32 maxStatus> REDBACKALERT =
                                Custom(REDBACKCUSTOMERGROUP ; PARAMETERS2)
                            {
                                logic
                                    state :
                                    {
                                        mutable float64 rate = 30.0 ;
                                        mutable int32 sum ;
                                    }

                                    onTuple REDBACKCUSTOMERGROUP :
                                    {
                                        if(((float64) status /(float64) maxStatus) <= rate / 100.0)
                                        {
                                            submit(REDBACKCUSTOMERGROUP, REDBACKALERT) ;
                                        }

                                    }

                                    onTuple PARAMETERS2 :
                                    {
                                        rate = REDBACKAlertRate ;
                                    }

                            }

                        stream<float64 MPLS_ID, int32 status, int32 maxStatus> MPLSALERT =
                                Custom(MPLSCUSTOMERGROUP ; PARAMETERS2)
                            {
                                logic
                                    state :
                                    {
                                        mutable float64 rate = 30.0 ;
                                        mutable int32 sum ;
                                    }

                                    onTuple MPLSCUSTOMERGROUP :
                                    {
                                        if(((float64) status /(float64) maxStatus) <= rate / 100.0)
                                        {
                                            submit(MPLSCUSTOMERGROUP, MPLSALERT) ;
                                        }

                                    }

                                    onTuple PARAMETERS2 :
                                    {
                                        rate = REDBACKAlertRate ;
                                    }

                            }

                        stream<float64 REDBACK_ID, int32 status, int32 redbackCount>
                            REDBACKALERT2 = Custom(REDBACKCUSTOMERGROUP2 ; PARAMETERS3)
                            {
                                logic
                                    state :
                                    {
                                        mutable int32 count = 5000 ;
                                    }

                                    onTuple REDBACKCUSTOMERGROUP2 :
                                    {
                                        if(redbackCount >= count)
                                        {
                                            submit(REDBACKCUSTOMERGROUP2, REDBACKALERT2) ;
                                        }

                                    }

                                    onTuple PARAMETERS3 :
                                    {
                                        count = REDBACKAlertCount ;
                                    }

                            }

                        stream<float64 MPLS_ID, int32 status, int32 mplsStopCount> MPLSALERT2 =
                                Custom(MPLSCUSTOMERGROUP2 ; PARAMETERS3)
                            {
                                logic
                                    state :
                                    {
                                        mutable int32 count = 5000 ;
                                    }

                                    onTuple MPLSCUSTOMERGROUP2 :
                                    {
                                        if(mplsStopCount >= count)
                                        {
                                            submit(MPLSCUSTOMERGROUP2, MPLSALERT2) ;
                                        }

                                    }

                                    onTuple PARAMETERS3 :
                                    {
                                        count = REDBACKAlertCount ;
                                    }

                            }

                        stream<float64 DSLAMAlertRate> PARAMETERS = FileSource()
                            {
                                param
                                    file : "parameters" ;
                                    format : txt ;
                            }

                        stream<float64 REDBACKAlertRate> PARAMETERS2 = FileSource()
                            {
                                param
                                    file : "parameters2" ;
                                    format : txt ;
                            }

                        stream<int32 REDBACKAlertCount> PARAMETERS3 = FileSource()
                            {
                                param
                                    file : "parameters3" ;
                                    format : txt ;
                            }

                        stream<AUGMENTEDRADIUSSTREAM> FilterVipsByStops = Filter(MATCHRULE)
                            {
                                param
                                    filter : IS_VIP == 1.0 && cdr_TYPE == "STOP" ; // && cdr_REASON != "USER_REQUEST" 

                            }

                        stream<rstring KULLANICI_KIMLIK, int32 filteredVipCount>
                            AggregateFilteredVIPsHourly = Aggregate(FilterVipsByStops as
                                inPort0Alias)
                            {
                                window
                                    inPort0Alias : sliding, time(3600), count(1), partitioned ;
                                param
                                    partitionBy : KULLANICI_KIMLIK ;
                                    aggregateIncompleteWindows : true ;
                                output
                                    AggregateFilteredVIPsHourly : filteredVipCount = Count() ;
                            }

                        stream<AggregateFilteredVIPsHourly> VipStopAlerts =
                                Custom(AggregateFilteredVIPsHourly ; ReadVipStopRatePARAM)
                            {
                                logic
                                    state : mutable int32 paramVipCount = 3 ;
                                    onTuple ReadVipStopRatePARAM : paramVipCount = vipLimit ;
                                    onTuple AggregateFilteredVIPsHourly : if(filteredVipCount >=
                                        paramVipCount) submit(AggregateFilteredVIPsHourly, VipStopAlerts) ;
                                }

                            stream<int32 vipLimit> ReadVipStopRatePARAM = FileSource()
                                {
                                    param
                                        file : "viplimit.txt" ;
                                        format : csv ;
                                }

                            () as WriteVipStopsToFile = FileSink(VipStopAlerts)
                                {
                                    param
                                        file : "vipalert.txt" ;
                                        format : csv ;
                                }

                            stream<float64 MPLS_ID, int32 status, float64 REDBACK_ID>
                                Filter_38_out0 = Functor(MATCHRULE)
                                {
                                    param
                                        filter : cdr_TYPE == "STOP" ;
                                    output
                                        Filter_38_out0 : status = 1 ;
                                }

}